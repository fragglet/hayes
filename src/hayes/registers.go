package hayes

import (
	"fmt"
	"sync"
	"sort"
	"strings"
)

var escSequence [3]byte = [3]byte{'+','+','+'}

type Registers struct {
	regs map[byte]byte
	current byte
	rlock sync.RWMutex
}

func NewRegisters() *Registers {
	var r Registers
	r.regs = make(map[byte]byte, __NUM_REGS)
	r.current = 0

	// fill in the existing registers so valid() works
	for i := byte(0); i < __NUM_REGS; i++ {
		r.regs[i] = 0
	}

	return &r
}

func (r *Registers) valid(regnum byte) bool {
	_, ok := r.regs[regnum]
	return ok
}

func ( r *Registers) ReadCurrent() byte {
	return r.Read(r.current)
}

// Note the locks here.
func ( r *Registers) SetCurrent(cur byte) {
	r.rlock.Lock()
	defer r.rlock.Unlock()
	r.current = cur
}

func ( r *Registers) ShowCurrent() byte {
	r.rlock.RLock()
	defer r.rlock.RUnlock()
	return r.current
}

func (r *Registers) Write(regnum, val byte) {
	if !r.valid(regnum) {
		panic("Writing to a non-existant register")
	}
	r.rlock.Lock()
	defer r.rlock.Unlock()
	r.regs[regnum] = val
}

func (r *Registers) Read(regnum byte) byte {
	if !r.valid(regnum) {
		panic("Writing to a non-existant register")
	}
	r.rlock.RLock()
	defer r.rlock.RUnlock()
	return r.regs[regnum]
}

func (r *Registers) Inc(regnum byte) byte {
	if _, ok := r.regs[regnum]; !ok {
		panic("Writing to a non-existant register")
	}
	r.rlock.Lock()
	defer r.rlock.Unlock()
	r.regs[regnum]++
	return r.regs[regnum]
}

func (r *Registers) activeRegisters() (i []byte) {
	r.rlock.RLock()
	defer r.rlock.RUnlock()
	for f := range r.regs {
		i = append(i, f)
	}
	sort.Sort(byBytes(i))
	return i
}

func (r *Registers) String() string {
	var s string
	for _, f := range r.activeRegisters() {
		s += fmt.Sprintf("S%03d:%03d ", f, r.Read(f))
		if (len(s) % 80) + 9 > 80 {
			s += "\n"
		}
	}
	return s
}

// Because sort.Bytes() doesn't exist.
type byBytes []byte
func (b byBytes) Len() int { return len(b) }
func (b byBytes) Swap(i, j int) { b[i], b[j] = b[j], b[i] }
func (b byBytes) Less(i, j int) bool { return b[i] < b[j] }

// Register constants
// TODO: Fill this out as per the manual
const (
	// Do auto answer (0 == false, 1 == true) - default 0
	REG_AUTO_ANSWER    = iota // 0

	// AA Ring counter (read only)
	REG_RING_COUNT		  // 1

	// Escape sequence character ASCII code.  Default '+'
	REG_ESC_CH		  // 2

	// ASCII value of the line terminating character.  Defualt ASCII 13 (<CR>)
	REG_CR_CH		  // 3

	// ASCII value of the line feed character.  Default ASCII 10 (<LF>)
	REG_LF_CH		  // 4

	// ASCII value of the backspace character.  Default is ASCII 8 (<BS>)
	REG_BS_CH		  // 5

	// determines how long the modem waits after going off-hook
	// before it dials.  Valid value is 4 - 7 seconds, factory
	// default is 4
	REG_BLIND_DIAL_WAIT	  // 6

	// time delay between dialing and responding to an incoming carrier signal
	REG_WAIT_FOR_CARRIER_AFTER_DIAL // 7

	// duration of the delay generated by the comma (,) dial modifier
	REG_COMMA_DELAY				  // 8 seconds a

	// carrier signal must be present for the modem to recognize
	// it and issue a carrier detect
	REG_CARRIER_DETECT_RESPONSE_TIME	  // 9

	// time between loss of remote carrier and local modem disconnect (0.1s)
	REG_DELAY_BETWEEN_LOST_CARRIER_AND_HANGUP // 10

	// uration and spacing of tones in multi-frequency tone dialing
	REG_MULTIFREQ_TONE_DURATION		  // 11 delay required

	// prior to and following the escape sequence.  In 1/50's of a
	// second.  Factory default is 50 (1 second)
	REG_ESC_CODE_GUARD_TIME			  // 12

	__NUM_REGS		// This must be last

)

// Given a parsed register command, execute it.
func (m *Modem) registerCmd(cmd string) error {
	var err error
	var reg, val int

	r := m.registers

	// NOTE: The order of these stanzas is critical.

	// S? - query selected register
	if cmd[:2] == "S?" {
		m.serial.Printf("%d\n", r.ReadCurrent())
		return OK
	}

	// Sn=x - write x to n
	_, err = fmt.Sscanf(cmd, "S%d=%d", &reg, &val)
	if err == nil {
		if reg > __NUM_REGS || reg < 0 {
			m.log.Printf("Register index over/underflow: %d", reg)
			return ERROR
		}
		if val > 255 || val < 0 {
			m.log.Printf("Register value over/underflow: %d", val)
			return ERROR
		}

		// Update modem state
		switch reg {
		case REG_AUTO_ANSWER:
			if val == 0 {
				m.led_AA_off()
			} else {
				m.led_AA_on()
			}
		case REG_ESC_CODE_GUARD_TIME:
			if val > 255 {
				return ERROR
			}
			m.resetTimer()
		case REG_ESC_CH:
			escSequence[0] = byte(val)
			escSequence[1] = byte(val)
			escSequence[2] = byte(val)
		case REG_BLIND_DIAL_WAIT:
			if val < 2 || val > 255 {
				return ERROR
			}
		case REG_COMMA_DELAY:
			if val > 65 {
				return ERROR
			}
		case REG_BS_CH, REG_LF_CH, REG_CR_CH:
			if val > 127 {
				return ERROR
			}
		}

		r.Write(byte(reg), byte(val))
		return OK
	}

	// Sn? - query register n
	_, err = fmt.Sscanf(cmd, "S%d?", &reg)
	if err == nil {
		if reg > __NUM_REGS || reg < 0 {	
			m.log.Printf("Register index over/underflow: %d", reg)
			return ERROR
		}
		
		m.serial.Printf("%d\n", r.ReadCurrent())
		return OK
	}

	// Sn - slect register
	_, err = fmt.Sscanf(cmd, "S%d", &reg)
	if err == nil {
		if reg > __NUM_REGS || reg < 0 {	
			m.log.Printf("Register index over/underflow: %d", reg)
			return ERROR
		}
		r.SetCurrent(byte(reg))
		return OK
	}

	if err != nil {
		m.log.Printf("registers(): err = %s", err)
	}
	return ERROR
}

// ATS...
// Given a string that looks like a "S" command, parse & normalize it
func parseRegisters(cmd string) (string, int, error) {
	var s string
	var err error
	var reg, val int

	// NOTE: The order of these stanzas is critical.

	if  len(cmd) < 2  {
		return "", 0, fmt.Errorf("Bad command: %s", cmd)
	}

	c := strings.ToUpper(cmd)

	// S? - query selected register
	if c[:2] == "S?" {
		s = "S?"
		return s, 2, nil
	}

	// Sn=x - write x to n
	_, err = fmt.Sscanf(c, "S%d=%d", &reg, &val)
	if err == nil {
		s = fmt.Sprintf("S%d=%d", reg, val)
		return s, len(s), nil
	}

	// Sn? - query register n
	_, err = fmt.Sscanf(c, "S%d?", &reg)
	if err == nil {
		s = fmt.Sprintf("S%d?", reg)
		return s, len(s), nil
	}

	// Sn - slect register
	_, err = fmt.Sscanf(c, "S%d", &reg)
	if err == nil {
		s = fmt.Sprintf("S%d", reg)
		return s, len(s), nil
	}

	return "", 0, fmt.Errorf("Bad S command: %s", cmd)
}

// Setup register defaults for the modem
func (m *Modem) resetRegs() {

	m.log.Print("Initializing registers")

	m.registers.Write(REG_AUTO_ANSWER, 0)
	m.registers.Write(REG_RING_COUNT, 0)
	m.registers.Write(REG_ESC_CH, byte('+'))
	m.registers.Write(REG_CR_CH, byte('\r'))
	m.registers.Write(REG_LF_CH, byte('\n'))
	m.registers.Write(REG_BS_CH, byte('\b'))
	m.registers.Write(REG_BLIND_DIAL_WAIT, 2)
	m.registers.Write(REG_WAIT_FOR_CARRIER_AFTER_DIAL, 50)
	m.registers.Write(REG_COMMA_DELAY, 2)
	m.registers.Write(REG_CARRIER_DETECT_RESPONSE_TIME, 6)
	m.registers.Write(REG_DELAY_BETWEEN_LOST_CARRIER_AND_HANGUP, 14)
	m.registers.Write(REG_MULTIFREQ_TONE_DURATION, 95)
	m.registers.Write(REG_ESC_CODE_GUARD_TIME, 50)
}
