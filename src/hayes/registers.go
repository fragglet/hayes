package main

import (
	"fmt"
	"sync"
	"sort"
	"strconv"
	"strings"
)

type Registers struct {
	regs [__NUM_REGS]struct {
		val byte
		valid bool
	}
	current int
	rlock sync.RWMutex
}

// Register constants
// TODO: Fill this out as per the manual
const (
	// Do auto answer (0 == false, 1 == true) - default 0
	REG_AUTO_ANSWER    = iota // 0

	// AA Ring counter (read only)
	REG_RING_COUNT		  // 1

	// Escape sequence character ASCII code.  Default '+'
	REG_ESC_CH		  // 2

	// ASCII value of the line terminating character.  Defualt ASCII 13 (<CR>)
	REG_CR_CH		  // 3

	// ASCII value of the line feed character.  Default ASCII 10 (<LF>)
	REG_LF_CH		  // 4

	// ASCII value of the backspace character.  Default is ASCII 8 (<BS>)
	REG_BS_CH		  // 5

	// determines how long the modem waits after going off-hook
	// before it dials.  Valid value is 4 - 7 seconds, factory
	// default is 4
	REG_BLIND_DIAL_WAIT	  // 6

	// time delay between dialing and responding to an incoming carrier signal
	REG_WAIT_FOR_CARRIER_AFTER_DIAL // 7

	// duration of the delay generated by the comma (,) dial modifier
	REG_COMMA_DELAY				  // 8 seconds a

	// carrier signal must be present for the modem to recognize
	// it and issue a carrier detect
	REG_CARRIER_DETECT_RESPONSE_TIME	  // 9

	// time between loss of remote carrier and local modem disconnect (0.1s)
	REG_DELAY_BETWEEN_LOST_CARRIER_AND_HANGUP // 10

	// uration and spacing of tones in multi-frequency tone dialing
	REG_MULTIFREQ_TONE_DURATION		  // 11 delay required

	// prior to and following the escape sequence.  In 1/50's of a
	// second.  Factory default is 50 (1 second)
	REG_ESC_CODE_GUARD_TIME			  // 12
)

const __NUM_REGS = 256

// Setup register defaults for the modem
func (r *Registers) Reset() {

	logger.Print("Initializing registers")

	r.Write(REG_AUTO_ANSWER, 0)
	r.Write(REG_RING_COUNT, 0)
	r.Write(REG_ESC_CH, byte('+'))
	r.Write(REG_CR_CH, byte('\r'))
	r.Write(REG_LF_CH, byte('\n'))
	r.Write(REG_BS_CH, byte('\b'))
	r.Write(REG_BLIND_DIAL_WAIT, 2)
	r.Write(REG_WAIT_FOR_CARRIER_AFTER_DIAL, 50)
	r.Write(REG_COMMA_DELAY, 2)
	r.Write(REG_CARRIER_DETECT_RESPONSE_TIME, 6)
	r.Write(REG_DELAY_BETWEEN_LOST_CARRIER_AND_HANGUP, 14)
	r.Write(REG_MULTIFREQ_TONE_DURATION, 95)
	r.Write(REG_ESC_CODE_GUARD_TIME, 50)

	// These are cosmetic, not functional.
	r.Write(18, 0)
	r.Write(25, 5)
	r.Write(26, 1)
	r.Write(36, 7)
	r.Write(37, 0)
	r.Write(38, 20)
	r.Write(44, 3)
	r.Write(46, 2)
	r.Write(48, 7)
	r.Write(49, 8)
	r.Write(50, 16)
	r.Write(97, 30)
	r.Write(108, 2)
	r.Write(109, 62)
	r.Write(110, 2)
}


var escSequence [3]byte = [3]byte{'+','+','+'}

func NewRegisters() Registers {
	var r Registers

	r.current = 0

	// fill in the existing registers so valid() works
	for i := 0; i < __NUM_REGS; i++ {
		r.regs[i].val = 0
		r.regs[i].valid = false
	}

	return r
}

func (r *Registers) valid(regnum uint) bool {
	r.rlock.Lock()
	defer r.rlock.Unlock()
	return r.regs[regnum].valid
}

func ( r *Registers) ReadCurrent() byte {
	return r.Read(r.current)
}

// Note the locks here.
func ( r *Registers) SetCurrent(regnum int) error {
	if regnum < 0 || regnum > __NUM_REGS {
		return fmt.Errorf("Invalid register numnber: %d", regnum)
	}
	r.rlock.Lock()
	defer r.rlock.Unlock()
	r.current = regnum
	return nil
}

func ( r *Registers) ShowCurrent() int {
	r.rlock.RLock()
	defer r.rlock.RUnlock()
	return r.current
}

func (r *Registers) Write(regnum int, val byte) error {
	if regnum < 0 || regnum > __NUM_REGS {
		return fmt.Errorf("Invalid register numnber: %d", regnum)
	}
	r.rlock.Lock()
	defer r.rlock.Unlock()
	r.regs[regnum].val = val
	r.regs[regnum].valid = true
	return nil
}

func (r *Registers) Read(regnum int) byte {
	if regnum < 0 || regnum > __NUM_REGS {
		panic("invalid read register")
	}
	r.rlock.RLock()
	defer r.rlock.RUnlock()
	if r.regs[regnum].valid {
		return r.regs[regnum].val
	}
	return 0
}

func (r *Registers) Inc(regnum int) byte {
	r.rlock.Lock()
	defer r.rlock.Unlock()
	r.regs[regnum].val++
	r.regs[regnum].valid = true
	return r.regs[regnum].val
}

func (r *Registers) activeRegisters() (i []int) {
	r.rlock.RLock()
	defer r.rlock.RUnlock()
	for f := 0; f < __NUM_REGS; f++ {
		if r.regs[f].valid {
			i = append(i, f)
		}
	}
	sort.Ints(i)
	return i
}

func (r *Registers) String() string {
	var s string
	for _, f := range r.activeRegisters() {
		s += fmt.Sprintf("S%02d:%03d ", f, r.Read(f))
	}
	return lineWrap(s, 80)
}

func (r Registers) JsonMap() map[string]byte {
	s := make(map[string]byte)
	for _, f := range r.activeRegisters() {
		k := strconv.Itoa(f)
		s[k] = r.Read(f)
	}
	return s
}

func registersJsonUnmap(m map[string]byte) Registers {

	nr := NewRegisters()
	for key, val := range m {
		i, err := strconv.Atoi(key)
		if err != nil {
			logger.Printf("Atoi(): %s", err)
			continue
		}
		if i < 0 || i > 255 {
			logger.Printf("Bad register in config: regnum = %d", i)
		} else {
			nr.Write(i, val)
		}
	}
	return nr
}

// Given a parsed register command, execute it.
func registerCmd(cmd string) error {
	var err error
	var reg, val int

	// NOTE: The order of these stanzas is critical.

	// S? - query selected register
	if cmd[:2] == "S?" {
		serial.Printf("%d\n", registers.ReadCurrent())
		return OK
	}

	// Sn=x - write x to n
	_, err = fmt.Sscanf(cmd, "S%d=%d", &reg, &val)
	if err == nil {
		if reg > __NUM_REGS || reg < 0 {
			logger.Printf("Register index over/underflow: %d", reg)
			return ERROR
		}
		if val > 255 || val < 0 {
			logger.Printf("Register value over/underflow: %d", val)
			return ERROR
		}

		// Update modem state
		switch reg {
		case REG_AUTO_ANSWER:
			if val == 0 {
				led_AA_off()
			} else {
				led_AA_on()
			}
		case REG_ESC_CODE_GUARD_TIME:
			if val > 255 {
				return ERROR
			}
			resetTimer()
		case REG_ESC_CH:
			escSequence[0] = byte(val)
			escSequence[1] = byte(val)
			escSequence[2] = byte(val)
		case REG_BLIND_DIAL_WAIT:
			if val < 2 || val > 255 {
				return ERROR
			}
		case REG_COMMA_DELAY:
			if val > 65 {
				return ERROR
			}
		case REG_BS_CH, REG_LF_CH, REG_CR_CH:
			if val > 127 {
				return ERROR
			}
		}

		registers.Write(reg, byte(val))
		return OK
	}

	// Sn? - query register n
	_, err = fmt.Sscanf(cmd, "S%d?", &reg)
	if err == nil {
		if reg > __NUM_REGS || reg < 0 {	
			logger.Printf("Register index over/underflow: %d", reg)
			return ERROR
		}
		logger.Printf("Reading register %d", reg)
		serial.Printf("%d\n", registers.Read(reg))
		return OK
	}

	// Sn - slect register
	_, err = fmt.Sscanf(cmd, "S%d", &reg)
	if err == nil {
		if reg > __NUM_REGS || reg < 0 {	
			logger.Printf("Register index over/underflow: %d", reg)
			return ERROR
		}
		registers.SetCurrent(reg)
		return OK
	}

	if err != nil {
		logger.Printf("registers(): err = %s", err)
	}
	return ERROR
}

// ATS...
// Given a string that looks like a "S" command, parse & normalize it
func parseRegisters(cmd string) (string, int, error) {
	var s string
	var err error
	var reg, val int

	// NOTE: The order of these stanzas is critical.

	if  len(cmd) < 2  {
		return "", 0, fmt.Errorf("Bad command: %s", cmd)
	}

	c := strings.ToUpper(cmd)

	// S? - query selected register
	if c[:2] == "S?" {
		s = "S?"
		return s, 2, nil
	}

	// Sn=x - write x to n
	_, err = fmt.Sscanf(c, "S%d=%d", &reg, &val)
	if err == nil {
		s = fmt.Sprintf("S%d=%d", reg, val)
		return s, len(s), nil
	}

	// Sn? - query register n
	_, err = fmt.Sscanf(c, "S%d?", &reg)
	if err == nil {
		s = fmt.Sprintf("S%d?", reg)
		return s, len(s), nil
	}

	// Sn - slect register
	_, err = fmt.Sscanf(c, "S%d", &reg)
	if err == nil {
		s = fmt.Sprintf("S%d", reg)
		return s, len(s), nil
	}

	return "", 0, fmt.Errorf("Bad S command: %s", cmd)
}

